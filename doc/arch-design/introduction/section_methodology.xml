<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section [
<!ENTITY % openstack SYSTEM "../../common/entities/openstack.ent">
%openstack;
]>
<section xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.0"
  xml:id="methodology">
    <title>Methodology</title>
    <para>
      Creating and testing use cases is the best way to design a cloud
      architecture that best suits your needs.</para>
    <para>
      For example, if your goal is to develop a cloud for your company's e-commerce
      website, you need to plan for applications that will support thousands of
      sessions per second, variable workloads, and lots of complex and changing data.
      By identifying the key meters, such as number of concurrent transactions
        per second, size of database, and so on, it is possible to then build a
        method for testing the assumptions.</para>
    <para>
        Functional user scenarios are used to develop test cases to measure overall
        project trajectory. If you do not want to use an application to develop user
        requirements automatically, you will need to create requirements to build
        test harnesses and develop usable meters. Once the meters are established you
        can respond to changes quickly without having to set the exact requirements
        in advance. This creates ways to configure the system, rather than redesigning
        it every time there is a requirements change.</para>
      <para>
        It is important to limit scope creep. Ensure you address tool limitations
        for the requirements, but do not recreate the entire suite of tools. Work
        with technical product owners to establish critical features that are needed
        for a successful cloud deployment.</para>
    <section xml:id="application-cloud-readiness-methods">
        <title>Application cloud readiness</title>
        <para>Although the cloud is designed to make things easier, it is
            important to realize that "using cloud" is more than just firing up
            an instance and dropping an application on it. This "lift and shift"
            approach works in certain situations, but there is a fundamental
            difference between clouds and traditional bare-metal-based
            environments, or even traditional virtualized environments.</para>
        <para>In traditional environments, with traditional enterprise
            applications, the applications and the servers that run on them are
            "pets". They're lovingly crafted and cared for, the servers have
            names like Gandalf or Tardis, and if they get sick, someone nurses
            them back to health. All of this is designed so that the application
            does not experience an outage.</para>
        <para>In cloud environments, on the other hand, servers are more like
            cattle. There are thousands of them, they get names like NY-1138-Q,
            and if they get sick, they get put down and a sysadmin installs
            another one. Traditional applications that are unprepared for this
            kind of environment, naturally will suffer outages, lost data, or
            worse.</para>
        <para>There are other reasons to design applications with cloud in mind.
            Some are defensive, such as the fact that applications cannot be
            certain of exactly where or on what hardware they will be launched,
            they need to be flexible, or at least adaptable. Others are
            proactive. For example, one of the advantages of using the cloud is
            scalability, so applications need to be designed in such a way that
            they can take advantage of those and other opportunities.</para>
    </section>
    <section xml:id="determining-whether-an-application-is-cloud-ready">
        <title>Determining whether an application is cloud-ready</title>
        <para>There are several factors to take into consideration when looking
            at whether an application is a good fit for the cloud.</para>
            <variablelist>
              <varlistentry>
                <term>Structure</term>
                <listitem>
                  <para>
                    A large, monolithic, single-tiered legacy
                    application typically isn't a good fit for the
                    cloud. Efficiencies are gained when load can be
                    spread over several instances, so that a failure
                    in one part of the system can be mitigated without
                    affecting other parts of the system, or so that
                    scaling can take place where the app needs
                    it.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Dependencies</term>
                <listitem>
                  <para>
                    Applications that depend on specific
                    hardware&mdash;such as a particular chip set or an
                    external device such as a fingerprint
                    reader&mdash;might not be a good fit for the
                    cloud, unless those dependencies are specifically
                    addressed. Similarly, if an application depends on
                    an operating system or set of libraries that
                    cannot be used in the cloud, or cannot be
                    virtualized, that is a problem.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Connectivity</term>
                <listitem>
                  <para>
                    Self-contained applications or those that depend
                    on resources that are not reachable by the cloud
                    in question, will not run. In some situations,
                    work around these issues with custom network
                    setup, but how well this works depends on the
                    chosen cloud environment.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Durability and resilience</term>
                <listitem>
                  <para>
                    Despite the existence of SLAs, things break:
                    servers go down, network connections are
                    disrupted, or too many tenants on a server make a
                    server unusable. An application must be sturdy
                    enough to contend with these issues.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
    </section>
    <section xml:id="designing-for-the-cloud">
        <title>Designing for the cloud</title>
        <para>Here are some guidelines to keep in mind when designing an
            application for the cloud:</para>
        <itemizedlist>
            <listitem>
                <para>Be a pessimist: Assume everything fails and design
                    backwards. Love your chaos monkey.</para>
            </listitem>
            <listitem>
                <para>Put your eggs in multiple baskets: Leverage multiple
                    providers, geographic regions and availability zones to
                    accommodate for local availability issues. Design for
                    portability.</para>
            </listitem>
            <listitem>
                <para>Think efficiency: Inefficient designs will not scale.
                    Efficient designs become cheaper as they scale. Kill off
                    unneeded components or capacity.</para>
            </listitem>
            <listitem>
                <para>Be paranoid: Design for defense in depth and zero
                    tolerance by building in security at every level and between
                    every component. Trust no one.</para>
            </listitem>
            <listitem>
                <para>But not too paranoid: Not every application needs the
                    platinum solution. Architect for different SLA's, service
                    tiers and security levels.</para>
            </listitem>
            <listitem>
                <para>Manage the data: Data is usually the most inflexible and
                    complex area of a cloud and cloud integration architecture.
                    Don't short change the effort in analyzing and addressing
                    data needs.</para>
            </listitem>
            <listitem>
                <para>Hands off: Leverage automation to increase consistency and
                    quality and reduce response times.</para>
            </listitem>
            <listitem>
                <para>Divide and conquer: Pursue partitioning and
                    parallel layering wherever possible. Make components as small
                    and portable as possible. Use load balancing between layers.
                </para>
            </listitem>
            <listitem>
                <para>Think elasticity: Increasing resources should result in a
                    proportional increase in performance and scalability.
                    Decreasing resources should have the opposite effect.
                </para>
            </listitem>
            <listitem>
                <para>Be dynamic: Enable dynamic configuration changes such as
                    auto scaling, failure recovery and resource discovery to
                    adapt to changing environments, faults and workload volumes.
                </para>
            </listitem>
            <listitem>
                <para>Stay close: Reduce latency by moving highly interactive
                    components and data near each other.</para>
            </listitem>
            <listitem>
                <para>Keep it loose: Loose coupling, service interfaces,
                    separation of concerns, abstraction and well defined API's
                    deliver flexibility.</para>
            </listitem>
            <listitem>
                <para>Be cost aware: Autoscaling, data transmission, virtual
                    software licenses, reserved instances, and so on can rapidly
                    increase monthly usage charges. Monitor usage closely.
                </para>
            </listitem>
        </itemizedlist>
    </section>
</section>
